# Итак, вы хотите научиться функциональному программированию (Часть 6)
*Перевод статьи [Charles Scalfani](https://medium.com/@cscalfani): [So You Want to be a Functional Programmer (Part 6)](https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-6-db502830403) с [наилучшими пожеланиями от автора](https://twitter.com/cscalfani/status/933052963781722112).*

![Эволюция парадигм программирования](https://cdn-images-1.medium.com/max/800/1*AM83LP9sGGjIul3c5hIsWg.png)

Первый шаг к пониманию идей функционального программирования – самый важный и иногда самый сложный шаг. Но с правильным подходом никаких трудностей быть не должно.

Предыдущие части: [Часть 1](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-1-6ef98e90d58d), [Часть 2](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-2-ae095d9807b3), [Часть 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158), [Часть 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da), [Часть 5](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-5-d78044d54675).

## Что теперь?

![Вырвитесь из целофанновой реальности](https://cdn-images-1.medium.com/max/800/1*yVZA0aT5t6crvBPAMn46Kg.png)

Теперь, когда вы изучили весь этот новый замечательный материал, вы, возможно, подумаете: «И что теперь? Как мне использовать это в моём обычном коде?».

Здесь возможны разные варианты. Если вы умеете программировать на чистом функциональном языке типа Elm или Haskell, тогда вам будет легко привести в действие механизмы всех этих идей и подобные языки позволят сделать это просто.

Если же вы умеете программировать только на императивном языке типа JavaScript (на уровне, которым мы все должны владеть), тогда вы можете продолжить использовать всё, что уже изучили, но теперь дисциплинируя себя. 

## Функциональный JavaScript

![Работает, как часы](https://cdn-images-1.medium.com/max/800/1*w_gG-CXQX4TV3B5bN24nqg.png)

JavaScript имеет множество фич, позволяющих вам программировать на более функциональный манер. Полной чистоты не будет, но вы можете добиться некоторой неизменяемости с помощью самого языка и ещё большей с помощью библиотек.

Идеально не будет, но если вам нужно использовать функциональные возможности, тогда почему бы не привлечь некоторые преимущества языка?

### Неизменяемость

Первая вещь, принимаемая во внимание – это неизменяемость. В ES2015 или ES6, как он ещё называется, появилось новое ключевое слово для объявления переменных – `const`. Оно означает, что если переменная была установлена однажды, она не может быть переопределена:

```js
const a = 1;
a = 2; // выбросит TypeError в Chrome, Firefox или Node
       // но не в Safari (на момент 10/2016)
       // (прим. пер., в Safari всё хорошо с версии 10.1)
```

Здесь `a` определена как константа и по этой причине не может быть изменена после установки. Вот почему выражение `a = 2` выбрасывает ошибку.

Проблема `const` в том, что в JavaScript она не заходит в своей идее так далеко, как должна. Следующий пример проиллюстрирует её предел:

```
const a = {
    x: 1,
    y: 2
};
a.x = 2; // НЕТ ИСКЛЮЧЕНИЯ!
a = {}; // а вот это выбросит TypeError
```

Заметьте, что `a.x = 2` НЕ выбрасывает исключения. Единственное значение, остающееся неизменяемым с `const` – это сама переменная `a`. Всё, что `a` в себе определяет, может быть изменено. 

Это ужасное разочарование, потому что отсутствие такого недостатка сделало бы JavaScript гораздо лучше.

Как же мы можем достичь полной неизменяемости в JavaScript?

К сожалению, это возможно только с помощью библиотеки [Immutable.js](https://facebook.github.io/immutable-js/). Она должна дать нам должный уровень неизменяемости, но, увы, её использование также сделает наш код больше похожим на Java, чем на JavaScript.

### Каррирование и композиция

Раннее, в одной из предыдущих частей, мы научились писать каррированные функции. Вот более сложный пример по этому поводу:

```js
const f = a => b => c => d => a + b + c + d;
```

Обратите внимание, что нам пришлось написать каррированный фрагмент функции вручную.

И, чтобы вызвать `f`, мы должны написать:

```js
console.log(f(1)(2)(3)(4)); // выведет 10
```

Но круглых скобок здесь достаточно, чтобы заставить плакать Lisp-программиста.

Существует множество библиотек, облегчающих задачу каррирования. Одна из моих любимых – [Ramda](http://ramdajs.com/).

Использование Ramda теперь позволяет нам написать:

```js
const f = R.curry((a, b, c, d) => a + b + c + d);
console.log(f(1, 2, 3, 4)); // выведет 10
console.log(f(1, 2)(3, 4)); // также выведет 10
console.log(f(1)(2)(3, 4)); // также выведет 10
```

Определение функции стало выглядеть не намного лучше, зато теперь нам удалось избавиться от нужды во всех этих круглых скобках. Заметьте, что мы можем применять угодное нам количество параметров, когда вызываем `f`: столько же или всего несколько.

Используя Ramda, мы можем переписать функцию `mult5AfterAdd10` из [Части 3](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-3-d1f567656158) и [Части 4](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-4-58edb490d0da):

```js
const add = R.curry((x, y) => x + y);
const mult5 = value => value * 5;
const mult5AfterAdd10 = R.compose(mult5, add(10));
```

Пример показывает, что Ramda имеет множество вспомогательных функций для выполнения подобных задач, к примеру `R.add` и `R.multiply`, что означает для нас меньшее количество кода:

```js
const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));
```

### `map`, `filter`, `reduce`

Ramda также имеет свои собственные версии `map`, `filter` и `reduce`. Несмотря на то, что эти функции находятся в `Array.prototype` в нативном JavaScript, их версии в Ramda каррированные:

```js
const isOdd = R.flip(R.modulo)(2);
const onlyOdd = R.filter(isOdd);
const isEven = R.complement(isOdd);
const onlyEven = R.filter(isEven);

const numbers = [1, 2, 3, 4, 5, 6, 7, 8];
console.log(onlyEven(numbers)); // выводит [2, 4, 6, 8]
console.log(onlyOdd(numbers)); // выводит [1, 3, 5, 7]
```

`R.modulo` принимает два параметра. Первый – это ***делимое*** (то, что мы делим), второй – ***делитель*** (то, на что мы делим).

Функция `isOdd` возвращает остаток от деления на два. При остатке от нуля чётного числа возвращается ***ложь***, при остатке от единицы нечётного числа – ***истина***. Мы перебросили (*прим. пер., `flip`*) первый и второй параметр из `modulo`, поэтому смогли установить `2`, как делитель.

Функция `isEven` – просто обратная (*прим. пер., `complement`*) версия `isOdd`.

Функция `onlyOdd` – ***фильтрующая*** функция с предикатом (функцией, возвращающей булево значение) `isOdd`. Перед выполнением она ожидает последнее значение в переданном списке чисел.

Функция `onlyEven` – ***фильтр***, использующий `isEven` в качестве предиката.

Когда мы передаём `number` в `onlyEven` и в `onlyOdd`, `isEven` и `isOdd` получают свои последние параметры и могут наконец-то выполниться, возвратив ожидаемые числа. 

## Недостатки JavaScript

![Или всё-таки нет...](https://cdn-images-1.medium.com/max/800/1*GjSzT5C7dKD0GPgSZVFGIw.png)

Со всеми библиотеками и расширенными средствами языка, которые получил JavaScript, он остаётся страдать из-за того факта, что является императивным языком программирования, пытающимся быть всем и для всех.

Большинство фронтенд-разработчиков застряли на одном месте, используя JavaScript для браузера, потому что он долгое время оставался единственным вариантом. Но сейчас многие разработчики уходят от написания JavaScript-кода напрямую.

Вместо этого они пишут на других языках и компилируют или, выражаясь точнее, транспилируют их в JavaScript.

Одним из первым таких языков был CoffeeScript. Сейчас на вооружение Angular 2 (*прим. пер., «сейчас» актуально для Angular 5*) был принят TypeScript. Транспилятором для JavaScript является Babel. 

Всё больше и больше людей прибегают к такому подходу в продакшене.

Но все эти языки начинали с JavaScript и только сделали его немного лучше. Почему бы не пойти до конца и не транспилировать JavaScript из чистого функционального языка?

## Elm

![Elm](https://cdn-images-1.medium.com/max/800/1*oVJSlb6bJfNCXYacQmcvew.png)

В серии статей мы обращались к Elm, чтобы лучше понять функциональное программирование.

***Но что такое Elm? И как мне использовать его?***

Elm – это чистый функциональный язык, компилируемый в JavaScript, поэтому вы можете использовать его для создания веб-приложений, используя [The Elm Architecture](https://guide.elm-lang.org/architecture/), также называемую TEA (эта архитектура вдохновила разработчиков Redux).

У приложений, написанных на Elm, НЕ возникает никаких ошибок выполнения.

Elm используется в продакшене такими компаниями, как [NoRedInk](https://www.noredink.com/), где Эван Чаплики, создатель Elm, сейчас работает (раньше он работал в [Prezi](https://prezi.com/)).

Послушайте монолог [6 Months of Elm in Production](https://www.youtube.com/watch?v=R2FtMbb-nLs) от Ричарда Фельдмана, Elm-евангелиста из NoRedInk, для более подробной информации.

***Должен ли я заменить весь свой JavaScript на Elm?***

Нет. Вы можете постепенно заменять части кода. Чтобы узнать побольше, загляните в статью [How to use Elm at Work](http://elm-lang.org/blog/how-to-use-elm-at-work) из блога Elm. 

***Зачем учить Elm?***

1. Программирование на чистом функциональном языке несёт в себе одновременно ограничение и освобождение. Ограничение заключается в ограничении ваших действий (зачастую, это защита вас от вас самих), но в тоже время вы освобождаетесь от ошибок и плохих архитектурных решений, так как Elm-приложения следуют The Elm Architecture, функционально-реактивной модели.

2. Функциональное программирование усовершенствует ваши навыки программиста. Все вышеупомянутые идеи – лишь верхушка айсберга. Вам действительно стоит увидеть их практическую реализацию, чтобы оценить насколько ваши программы уменьшатся в размере и вырастут в показателях стабильности.

3. JavaScript был изначально написан за десять дней и затем пропатчен в течение двух следующих десятков дней, чтобы превратиться в немного функциональный, немного объектно-ориентированный и полноценный императивный язык программирования.
Elm был разработан с учётом накопленного за тридцать лет опыта развития Haskell-сообщества, опирающегося на десятилетия работы в области математики и информатики.
The Elm Architecture (TEA) планировалась и улучшалась на протяжении многих лет и стала результатом личного достижения Эвана в функциональном реактивном программировании. Посмотрите [Controlling Time and Space](https://www.youtube.com/watch?v=Agu6jipKfYw), чтобы оценить уровень мышления, сформулировавшего эту архитектуру.

4. Elm был задуман для фронтенд-разработчиков. Он стремится сделать их жизнь проще. Посмотрите [Let’s Be Mainstream](https://www.youtube.com/watch?v=oYk8CKH7OhE), чтобы лучше понимать эту цель.

## Будущее

![Функциональный Гагарин](https://cdn-images-1.medium.com/max/800/1*0FpreasFPaa5rYns6Mpe6w.png)

Невозможно предугадать, что принесёт с собой завтрашний день, но мы можем произвести некоторые грамотные предположения. Вот некоторые из моих:

> *Произойдёт окончательный переход к языкам, компилируемым в JavaScript.*

> *Идеи функционального программирования, витающие вокруг да около на протяжении сорока лет, заново откроют себя, чтобы решить наши насущные проблемы сложности программного обеспечения.*

> *Состояние аппаратного обеспечения, в частности гигабайты дешёвой памяти и быстрые процессоры, сделает функциональные методы жизнеспособными.*

> *Центральные процессоры не станут работать быстрее, но количество ядер будет продолжать расти.*

> *Изменяющееся состояние будет осмысленно, как одна из основных проблем сложных систем.*

Я написал эту серию статей, потому что верю, что за функциональным программированием будущее и потому что последнюю пару лет прикладывал все усилия, чтобы освоить его (и я всё ещё учусь).

Моей целью являлось помочь другим освоить все эти концепты легче и быстрее, чем мне самому, и помочь другим поднять их уровень в программировании, чтобы они стали более востребованными специалистами.

Даже если мой тезис о том, что Elm станет весомым языком в будущем, неверен, я могу сказать с достаточной уверенностью, что функциональное программирование и Elm находятся на одной траектории с движением будущего.

Я надеюсь, что после прочтения этих статей, вы чувствуете себя более уверенными в своих способностях и понимаете эти идеи.

Желаю вам удачи в ваших будущих начинаниях.

---

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/%D0%B4%D0%B5%D0%B2%D1%88%D0%B0%D1%85%D1%82%D0%B0/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

[Статья на Medium](https://medium.com/devschacht/charles-scalfani-so-you-want-to-be-a-functional-programmer-part-6-9d13e599bd4d)
