# Сигнатура типов функции в JavaScript

*Перевод статьи [Functional Reactive Ninja](https://hackernoon.com/@lunasunkaiser): [Function Type Signatures in Javascript](https://hackernoon.com/function-type-signatures-in-javascript-5c698c1e9801).*

![](https://cdn-images-1.medium.com/max/800/1*Wh9B3SwVwDm0bVSB3A4MFw.png)

Когда разработчик Javascript начинает познавать самые глубокие секреты функционального программирования, он часто встречает эти странные *стрелки с типом*, написанные над функциями, и думает: «*Что за черт?*». В конце концов, он мастер динамически типизированного Javascript, свободный от ограничений типов.

Эти записи типов представляют собой метаязык под названием **сигнатуры типов** (*Type Signatures*), который может много чего рассказать о чистой функции и имеет намного большее значение в функциональном программировании, *чем вы могли бы ожидать*.

![](https://cdn-images-1.medium.com/max/800/1*8zKb9lvzV7n-DBIg8rBvzg.png)<br/>
*Скриншот из [ramdajs](http://ramdajs.com/docs/)*

*Давайте посмотрим, что такое сигнатуры типов и почему мы должны использовать их в нашем коде.*

> Сигнатура типов определяет входящие и возвращаемые типы для функции, иногда включая число аргументов, типы аргументов и порядок аргументов, содержащихся в функции.

Сигнатуры типов - очень точные высказывания, написанные сверху чистых функций, и использующиеся для отслеживания их работы.

Сигнатуры типов основаны на системе типов [Хиндли-Милнера](https://ru.wikipedia.org/wiki/Система_типов_Хиндли_—_Милнера) как стандартной системе типов для языков [ML](https://ru.wikipedia.org/wiki/ML), включая Haskell.

Эти высказывания служат великой цели **формализации** функционального выражения в алгоритмах Type Inferring (широко распространены в Haskell), но пока мы будем использовать их для более качественного документирования нашего кода Javascript и получения из него **произвольных теорем**.

И если вы обнаружите какую-либо чистую функцию, задокументированную сигнатурами типов, способность понимать их даст вам наглядное представление о работе этой функции.

![](https://cdn-images-1.medium.com/max/800/1*owhYyEq_wSRyPN_OuyQXPQ.gif)<br/>
*Прям как Хи-Мен*

Мы будем создавать сигнатуры типов как комментарии над нашими функциями. Вы также можете использовать [Flow](https://flow.org/) для вывода типов при использовании функций. Можете начать знакомство с Flow с [этого](https://medium.com/@lunasunkaiser/type-checking-with-flow-4db5ef9b3095).

## Простые функции

```js
// length :: String → Number
const length = s => s.length;
```

Вышеуказанная функция принимает строку и возвращает число. Если мы посмотрим внимательно, мы увидим:

1. Сначала записывается имя функции, а затем `::`.
2. Входящий тип записывается перед стрелкой.
3. Возвращаемый тип записывается после стрелки или в самом конце.

Помните, что записываются только входящие и возвращаемые типы, так что высказывание можно прочитать вот так: «Функция `length` от строки до числа».

Вышеупомянутая функция `length` также может быть записана как:

```js
// length :: [Number] → Number
const length = arr => arr.length
```

И это нормально, чтобы функция имела множественные сигнатуры, пока это удобно. Если функция становится слишком гибкой из-за типов своего параметра, тогда мы должны использовать **произвольные переменные Хиндли-Милнера** - мы обсудим их ниже.

## Несколько параметров

В отличие от других функциональных языков, в Javascript мы можем иметь функции с несколькими параметрами. Однако хорошая практика - за один раз вызывать функцию только с одним параметром. Если мы все ещё хотим использовать в наших функциях несколько параметров, мы сможем это сделать.

```js
// join :: (String, [String]) → String
const join = (separator, arr) => arr.join(separator)
```


## Функции высшего порядка
*Это не функциональное программирование, если у нас нет функций, работающих на функциях*

```js
// addOneToAll :: ((Number → Number),[Number]) → [Number]
const addOneToAll = (addOne = x=>x+1 , arr) => arr.map(addOne)
```

Когда функция передаётся в качестве параметра, мы заключаем её в круглые скобки, чтобы представить более понятную сигнатуру типов.

Вышеупомянутая функция является функцией «*map*», и она не работает только с конкретными типами данных: она может работать с любым типом массива. Поэтому для описания таких функций нам нужно что-то ещё.

## Произвольные переменные Хиндли-Милнера

*Такие функции, как `identity`, `map`, `filter` и `reduce`, принимают аргументы, являющиеся слишком гибкими, чтобы определяться конкретным типом, поэтому мы используем классические переменные Хиндли-Милнера `a` и `b`*

```js
// identity :: a → a
const identity = a => a
```

Поскольку `identity` всегда будет давать нам тот же возвращаемый тип для одного и того же входящего типа, мы использовали `a → a` для представления его сигнатуры.

![](https://cdn-images-1.medium.com/max/800/1*rtTpcLzjHB-TfCdnwZPtIA.gif)<br/>
*Я знаю!*

Также нашу функцию `length` можно записать так:

```js
// length :: [a] → Number
const length = arr => arr.length
```

По аналогии:

```js
// head :: [a] → a
const head = arr => arr[0]
```

## [Thunks](https://daveceddia.com/what-is-a-thunk/) или каррированные функции

*Сигнатуры типов самых чистых из чистых функций✨*

Для функций, принимающих несколько аргументов, всегда хороший вариант - каррировать их, чтобы позже сделать из них композицию в нашем коде. Кроме того, не рекомендуется использовать произвольные переменные Хиндли-Милнера с функциями с несколькими аргументами.

Если вам интересно, [почему мы должны каррировать наши функции](https://medium.com/devschacht/functional-reactive-ninja-partial-application-of-functions-99fc21d629ff), перейдите [сюда](https://medium.com/devschacht/functional-reactive-ninja-partial-application-of-functions-99fc21d629ff).

```
// map :: (a → b) → [a] → [b]
const map = fn => arr => arr.map(fn)
```

Стандартная функция `map` будет иметь указанную выше сигнатуру типов. Но также можно встретить `map` с такой сигнатурой типа:

```
map :: [a] → [b]
```

Иногда мы знаем тип массива, возвращаемого `map`, как в этом случае.

```js
// allToString :: [a] → [String]
const allToString = arr => arr.map(toString)
```

Давайте посмотрим на стандартные `filter` и `reduce`

```
// filter :: (a → bool) → [a] → [a]
const filter = fn => arr => arr.filter(fn)

// reduce :: (b → a → b) → b → [a] → b
const reduce = fn => init => arr => arr.reduce(fn, init)

```

Ясно, что сигнатура типов функции `reduce` немного сложна. Зато если мы сможем понять, как написать сигнатуру типов функции `reduce`, мы сможем написать сигнатуру типов для почти любой функции.

Итак, первый аргумент `reduce` - это **функция уменьшения**, принимающая `b` и `a`, чтобы вернуть `b`. Это означает, что функция будет уменьшать все в тип `b`, поэтому конечное значение, полученное из `reduce()` и предоставленное начальное значение (`init`), будут иметь значение типа `b`. И так как каждое отдельное значение из списка типа `a` будет проходить через эту функцию уменьшения, поэтому второй аргумент функции уменьшения должен быть типа `a`. Поэтому такая сигнатура типов `reduce()` является оправданной.

![](https://cdn-images-1.medium.com/max/800/1*5hga1wM83BuntHIvfwZyAw.gif)

## Произвольные теоремы

Другое назначение сигнатур типов - создавать *произвольные теоремы*. Эти теоремы очень полезны, когда мы имеем дело с **композициями чистых функций**, поскольку они помогают нам в оптимизации и рефакторинге нашего кода.

```js
// Сигнатура типов head следующая:
// head :: [a] → a

compose(map(fn), head) == compose(head, fn)
```

Это наша первая произвольная теорема, полученная исключительно из сигнатур типов функций `head` и `map`, которая гласит: если мы *сопоставим* (`map`) функцию `fn` на каждом элементе и затем возьмём *главу* (`head`) результирующего массива, то это будет эквивалентно применению функции `fn` на *главе* (`head`) массива.

Докажем эту теорему:

```js
compose(map(fn), head) == compose(head, fn)

--Переводим в сигнатуры типов--

[a] → [b] → b == [a] → a → b

-- Убираем промежуточные этапы --

[a] → b == [a] → b
```

Поскольку в общем сигнатуры типов обеих функций одинаковы, мы можем заключить, что обе композиции возвращают одинаковый результат для одинаковых входных данных.

![](https://cdn-images-1.medium.com/max/800/1*2yxW4P0pYnIlxew9FRrErg.gif)

Вышеприведенный вывод упрощен, так как для настоящего вывода произвольных теорем потребуются лямбда-вычисления, объяснение которых не является целью данной статьи.

Вы всегда можете пробежаться по [научной работе Вадлера о произвольных теоремах](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf), если хотите углубиться.

Обратите внимание, что функция `сompose`, используемая здесь, фактически противоположна идиоматическому `compose`. Больше информации [здесь](https://github.com/rajatsharma305/compose-r#compose-r).

----

Умение понимать и использовать сигнатуры типов полезно не только в Javascript, но и в других функциональных языках. Поэтому, если нам нужно заимствовать любую чистую функцию для Javascript, мы можем просто обратиться к её сигнатуре типов и понять, куда именно добавить функцию в наш код.

Спасибо за прочтение 💖

----

*Слушайте наш подкаст в [iTunes](https://itunes.apple.com/ru/podcast/девшахта/id1226773343) и [SoundCloud](https://soundcloud.com/devschacht), читайте нас на [Medium](https://medium.com/devschacht), контрибьютьте на [GitHub](https://github.com/devSchacht), общайтесь в [группе Telegram](https://t.me/devSchacht), следите в [Twitter](https://twitter.com/DevSchacht) и [канале Telegram](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht).*

[Ссылка на Medium](https://medium.com/devschacht/functional-reactive-ninja-function-type-signatures-in-javascript-283fe7cd6211)
