# V8: за кулисами (Мартовское издание. Запуск I+TF и декларативный JavaScript)

*Перевод статьи [Benedikt Meurer](http://benediktmeurer.de) [V8: Behind the Scenes (March Edition feat. I+TF launch and Declarative JavaScript)](http://benediktmeurer.de/2017/04/03/v8-behind-the-scenes-march-edition/). Опубликовано с разрешения автора.*

Я снова опаздываю c мартовским изданием, так что это может превратиться в некую традицию. В прошлом месяце было довольно интересно: мы наконец включили Ignition и TurboFan по умолчанию для Chrome M59. Потребовалось две попытки, но, похоже, теперь всё прижилось. В целом все прошло на удивление хорошо, несмотря на сложность и влияние этого изменения. Как сказал мой site director (*прим. пер.: к сожалению не удалось найти адекватный перевод этой должности на русский*): [«Переход с Crankshaft на TurboFan в Chrome был похож на смену движка болида F1 на скорости 250 км/ч»](https://twitter.com/holfelder/status/842473381832409093).

![](http://benediktmeurer.de/images/2017/landing-20170403.jpg)
[https://twitter.com/bmeurer/status/839337377671839744](https://twitter.com/bmeurer/status/839337377671839744)

Обратите внимание, что с этим переключением мы также удалили параметр enable-v8-future из chrome://flags и вместо него добавили выключатель disable-v8-ignition-turbo для новой конфигурации в Chrome M59. У этого выключателя есть три возможные настройки: Default, Disabled и Enabled. Если вы оставите его в Default, есть определенная вероятность, что вы получите старый конвейер компилятора даже на канале Canary или Dev из-за A/B тестирования. Установите для него значение «Отключено», чтобы быть уверенными, что вы получили новый конвейер, или установите его во «Включено», чтобы снова использовать Crankshaft и Full-Codegen.

![](http://benediktmeurer.de/images/2017/m59-20170403.png)

Включение новой конфигурации по умолчанию выявило несколько проблем, которые не были известны ранее, поэтому я был очень занят, помогая с их решением. Но, насколько я могу судить, сейчас все выглядит очень многообещающе.

В конце прошлого месяца я выступил с презентацией [TurboFan: новая архитектура генерации кода для V8](https://docs.google.com/presentation/d/1_eLlVzcj94_G4r9j9d_Lj5HRKFnq6jgpuPJtnmIBs88) на  Мюнхенской встрече Node.js User Group, рассказав немного о вещах, которые изменятся с новым конвейером. Самое главное, что включение нового конвейера значительно уменьшает общую сложность V8 и упрощает его перенос на новые архитектуры, а что ещё более важно с точки зрения пользователя, полностью исключает необходимость беспокоиться о так называемых *убийцах оптимизации*, поскольку TurboFan способен обрабатывать каждую конструкцию языка. Это не означает, что внезапно использование странной языковой конструкции, такой как  `with`, становится невероятно быстрым, но это означает, что присутствие одного из этих *убийц оптимизации* больше не отключает оптимизирующий компилятор для этой конкретной функции.

![](http://benediktmeurer.de/images/2017/optimization-killers-20170403.png)
Источник: [TurboFan: A new code generation architecture for V8](https://docs.google.com/presentation/d/1_eLlVzcj94_G4r9j9d_Lj5HRKFnq6jgpuPJtnmIBs88/edit#slide=id.g2134da681e_0_672), MNUG March '07 Meetup, [@bmeurer](https://twitter.com/bmeurer).

Вероятно, наиболее важными изменениями являются полностью оптимизируемые: операторы try-catch/try-finally, генераторы и асинхронные функции, и, конечно, теперь вы можете использовать let и const, не рискуя попасть в печально известный ["Unsupported phi use of const or let variable"](https://github.com/vhf/v8-bailout-reasons/issues/12).

Одно интересное и несколько неожиданное продолжение дискуссии, вызванное рекомендациями по оптимизации производительности, которые я назвал *декларативным JavaScript* в своём докладе:
![](http://benediktmeurer.de/images/2017/declarative-javascript-20170403.png)
[https://twitter.com/michaelhaeu/status/845003383153025024](https://twitter.com/michaelhaeu/status/845003383153025024)

*Мало того, что декларативный код легче читать, он также создает красивый байт-код и, следовательно, он быстрее. Спасибо [@bmeurer](https://twitter.com/bmeurer) [@munichnug](https://twitter.com/munichnug)*

Прежде всего, кажется, что некоторые люди сбиты с толку терминологией. Похоже, что использование понятий «явный против неявного» вместо «декларативный против неясного» для многих более понятно, поэтому просто представьте эти термины, когда смотрите на слайд выше. Однако главным спорным вопросом было то, имеет ли смысл использовать этот совет или предположить, что движок оптимизирует все это под капотом.

Имея бесконечные ресурсы, V8 мог бы генерировать улучшенный код и для правого слайда (и Crankshaft использовал это в прошлом), где он проверяет переменную в условии на то, что она является `undefined` или `Object`, и деоптимизирует во всех других случаях. Это уменьшает число проверок в оптимизированном коде. Однако этот подход имеет свою цену: он может деоптимизировать оптимизированный код, как только вводятся новые значения, а движку необходимо отслеживать, какие значения были видны для `obj` в базовом случае, что требует времени и памяти.

Но реальность такова: V8 не имеет бесконечных ресурсов. Фактически, когда все больше и больше бюджетных Android устройств заходит в мобильный интернет и все меньше и меньше трафика приходится на мобильные устройства или настольные компьютеры высокого класса, кажется, что в будущем у V8 (и Chrome) будет ещё меньше ресурсов. Снижение накладных расходов и менее агрессивная оптимизация помогли за последние два года значительно улучшить опыт работы на мобильных устройствах.

Иногда я слышу, как разработчики говорят, что эти проблемы при запуске не имеют значения для Node.js, и проблемы прогрева V8 не должны влиять на то, что они называют *серверной производительностью*, но затем я слышу, как они жалуются, что TypeScript, UglifyJS, Webpack, Babel и т.д. работают слишком медленно. Эти библиотеки также запускаются на V8 и также сильно страдают от накладных расходов во время прогрева или слишком агрессивной оптимизации, приводящей к частым деоптимизациям. Я видел много доказательств того, что уменьшение чрезмерной оптимизации помогло значительно уменьшить серверные нагрузки, как, например, измеряется в Node.js бенчмарке AcmeAir.

![](http://benediktmeurer.de/images/2017/acmeair-20170403.jpg)

Производительность улучшилась более чем на 45%, в основном за счет снижения оверхэда в V8. Эти измерения были выполнены на типичных клиентских рабочих нагрузках. Для типичных рабочих нагрузок на стороне сервера результат не так уж сильно отличается.

И ещё один важный аспект, который легко забывается: V8 – не единственный JavaScript движок, о котором вам следует беспокоиться. Он, безусловно, очень доминирует из-за его использования в Chrome, Node.js, Android и Opera, но ограничивать себя одним движком и производить оптимизации только для него (или надеяться на то, что некоторые оптимизации появятся в V8) – это, безусловно, не путь к успеху.

Говоря о примере выше, вопросы о том, оптимизирует ли движок [ToBoolean](https://tc39.github.io/ecma262/#sec-toboolean) или нет, и, в частности, какая обратная связь отслеживается и расходуется относительно входящих значений, являются и должны оставаться неважными. Если вы можете написать свой горячий код таким образом, чтобы его можно было оптимизировать независимо от определенных спекулятивных оптимизаций, вы должны одобрить этот способ. Например, когда у вас есть значение `obj`, которое может быть `undefined` или объектом, рассмотрите возможность исключения неопределенности через явное условие:

```js
if (obj !== undefined) {
  // …
}
```

или даже лучше:

```js
if (obj !== void 0) {
  // …
}
```

Это так же поможет вам понять ваш собственный код через два года, так как из этого

```js
if (obj) {
  // …
}
```

не ясно, что всё что вы хотели сделать – избежать `undefined` для `obj`.

Это особенно полезно иметь в виду при использовании `||` и `&&` в JavaScript. Например, я видел разработчиков, использующих `||` для реализации параметров по умолчанию, например:

```js
function foo(a, b) {
  a = a || "value";
  b = b || 4;
  // …
}
```

Когда я спросил, является ли пустая строка допустимым значением для `a` или является ли `0` допустимым значением для `b`, они были весьма удивлены, заметив, что таким образом они ошибочно отфильтровали допустимые входные данные. Так что не делайте этого! Вместо этого используйте функцию ES2015:

```js
function foo(a = "value", b = 4) {
  // …
}
```

Эта конструкция заменяет только значения `undefined` значениями по умолчанию, что является нормальным. Есть также [интересный аспект производительности](https://github.com/developit/preact/pull/610) при использовании `&&` и `||` в JavaScript. Я посмотрю, смогу ли я написать серию статей о *явном JavaScript* с удалением особого внимания аспектам производительности с точки зрения виртуальных машин, которые могут помочь пролить некоторый свет на эту тему.

Мой обычный дисклеймер: я не фронтенд инженер. У меня иные приоритеты, чем у вас (возможно), и у вас могут быть веские причины игнорировать любые советы, которые я здесь даю. Это совершенно нормально. Также будьте осторожны с переоптимизацией!

- - - -

*Читайте нас на [Медиуме](https://medium.com/devschacht), контрибьютьте на [Гитхабе](https://github.com/devSchacht), общайтесь в [группе Телеграма](https://t.me/devSchacht), следите в [Твиттере](https://twitter.com/DevSchacht) и [канале Телеграма](https://t.me/devSchachtChannel), рекомендуйте в [VK](https://vk.com/devschacht) и [Facebook](https://www.facebook.com/devSchacht). Скоро подъедет подкаст, не теряйтесь.*

[Статья на Medium](https://medium.com/devschacht/v8-behind-the-scenes-march-edition-5c53ed2c0467)
